{"version":3,"file":"useQueries.mjs","sources":["../../src/useQueries.ts"],"sourcesContent":["import 'client-only'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n"],"names":["useQueries","queries","context","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","React","useMemo","map","options","defaultedOptions","defaultQueryOptions","_optimisticResults","forEach","query","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","observer","useState","QueriesObserver","optimisticResult","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","undefined","subscribe","notifyManager","batchCalls","getCurrentResult","useEffect","setQueries","listeners","shouldAtLeastOneSuspend","some","result","index","shouldSuspend","suspensePromises","flatMap","queryObserver","getObservers","fetchOptimistic","willFetch","length","Promise","all","observerQueries","getQueries","firstSingleResultWhichShouldThrow","find","getHasError","useErrorBoundary","error"],"mappings":"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"}